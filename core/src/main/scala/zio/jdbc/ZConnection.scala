/*
 * Copyright 2022 John A. De Goes and the ZIO Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package zio.jdbc

import zio._

import java.sql.{ Connection, PreparedStatement, Statement }

/**
 * A `ZConnection` is a straightforward wrapper around `java.sql.Connection`. In order
 * to avoid needless duplication of code, one can safely access the underlying JDBC
 * `Connection` through the `access` method. Any such access will be attempted on the
 * blocking thread pool.
 */
final class ZConnection(private[jdbc] val stateful: ZStatefulConnection) extends AnyVal {

  private[jdbc] def access[A](f: Connection => A): ZIO[Any, Throwable, A] =
    ZIO.attemptBlocking(f(stateful.underlying))

  private[jdbc] def accessZIO[A](f: Connection => ZIO[Scope, Throwable, A]): ZIO[Scope, Throwable, A] =
    ZIO.blocking(f(stateful.underlying))

  def close: Task[Any] =
    access(_.close())

  def commit: Task[Unit] =
    access(_.commit())

  private[jdbc] def executeSqlWith[A](
    sql: SqlFragment
  )(f: PreparedStatement => ZIO[Scope, Throwable, A]): ZIO[Scope with Option[TransactionIsolationLevel], Throwable, A] =
    (for {
      isolationLevel <- ZIO.service[Option[TransactionIsolationLevel]]
      statement      <- ZIO.acquireRelease(
                          for {
                            _  <- isolationLevel match {
                                    case Some(level) =>
                                      stateful.setTransactionIsolation(level) *> stateful.setAutoCommit(false)
                                    case _           =>
                                      ZIO.unit
                                  }
                            ps <- {
                              val sb = new StringBuilder()
                              sql.foreachSegment(syntax => sb.append(syntax.value))(_ => sb.append("?"))
                              prepareStatement(sb.toString, Statement.RETURN_GENERATED_KEYS)
                            }
                          } yield ps
                        )(statement => ZIO.attemptBlocking(statement.close()).ignoreLogged)
      _              <- ZIO.attempt {
                          var paramIndex = 1
                          sql.foreachSegment(_ => ()) { param =>
                            param.setter.setValue(statement, paramIndex, param.value)
                            paramIndex += 1
                          }
                        }
      result         <- f(statement)
    } yield result).tapErrorCause { cause => // TODO: Question: do we want logging here, switch to debug for now
      ZIO.logAnnotate("SQL", sql.toString)(
        ZIO.logDebugCause(s"Error executing SQL due to: ${cause.prettyPrint}", cause)
      )
    }

  def getTransactionIsolation: Task[TransactionIsolationLevel] =
    for {
      levelRaw <- access(_.getTransactionIsolation)
      level    <- ZIO.fromEither(TransactionIsolationLevel.fromInt(levelRaw))
    } yield level

  def isClosed: Task[Boolean] =
    access(_.isClosed)

  /**
   * Return whether the connection is still alive or not,
   * trying to prepare a statement and managing the exception SQLException
   * if the connection can not do it.
   *
   * see: https://www.baeldung.com/jdbc-connection-status
   *
   * @return true if the connection is alive (valid), false otherwise
   */
  def isValid(): Task[Boolean] =
    for {
      closed    <- isClosed
      statement <- prepareStatement("SELECT 1")
      isAlive   <- ZIO.succeed(!closed && statement != null)
    } yield isAlive

  /**
   * Returns whether the connection is still alive or not, providing a timeout,
   * using the isValid(timeout) method on the java.sql.Connection interface
   *
   * see: https://www.baeldung.com/jdbc-connection-status
   *
   * @param zc the connection to look into
   * @return true if the connection is alive (valid), false otherwise
   */
  def isValid(timeout: Int): Task[Boolean] =
    access(_.isValid(timeout))

  def prepareStatement(sql: String): Task[PreparedStatement] =
    access(_.prepareStatement(sql))

  def prepareStatement(sql: String, autoGeneratedKeys: RuntimeFlags): Task[PreparedStatement] =
    access(_.prepareStatement(sql, autoGeneratedKeys))

  def rollback: Task[Unit] =
    access(_.rollback())

  def setAutoCommit(autoCommit: Boolean): Task[Unit] =
    stateful.setAutoCommit(autoCommit)

  def setTransactionIsolation(level: TransactionIsolationLevel): Task[Unit] =
    stateful.setTransactionIsolation(level)

}

object ZConnection {

  def apply(underlying: ZStatefulConnection): ZConnection =
    new ZConnection(underlying)
}
